# ===============================
from datetime import time
import json
import os
from pathlib import Path
from git import Repo
from github import Github
from dotenv import load_dotenv
from groq import Groq
import difflib

load_dotenv()

GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
REPO_OWNER = os.getenv("REPO_OWNER")
REPO_NAME = os.getenv("REPO_NAME")
LOCAL_REPO_PATH = "./repo_clone"
BRANCH_PREFIX = "issue-"

gh = Github(GITHUB_TOKEN)
client = Groq()
model = "llama-3.3-70b-versatile"


# -------- Tools ---------

def clone_or_pull_repo():
    if not os.path.exists(LOCAL_REPO_PATH):
        Repo.clone_from(f"https://github.com/{REPO_OWNER}/{REPO_NAME}.git", LOCAL_REPO_PATH)
        return "Cloned repo."
    else:
        repo = Repo(LOCAL_REPO_PATH)
        repo.remotes.origin.fetch()
        default_branch = repo.remotes.origin.refs[0].remote_head
        repo.git.checkout(default_branch)
        repo.git.reset('--hard', f'origin/{default_branch}')
        return f"Repo synced with origin/{default_branch}"


def list_files():
    p = Path(LOCAL_REPO_PATH)
    files = [str(f.relative_to(p)) for f in p.rglob("*") if f.is_file()]
    print(f"Files : {files}")
    return json.dumps(files)


def find_files(filename: str):
    files = json.loads(list_files())
    matched = [f for f in files if f.endswith(filename)]
    if not matched:
        return f"No files found matching '{filename}'."
    return json.dumps(matched)


def read_file(path: str):
    p = Path(LOCAL_REPO_PATH) / path
    if not p.exists():
        return f"File {path} not found."
    return p.read_text(encoding="utf8")


def write_file(path: str, content: str):
    p = Path(LOCAL_REPO_PATH) / path
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(content, encoding="utf8")
    return f"Wrote file {path}"


def get_diff(path: str, new_content: str):
    p = Path(LOCAL_REPO_PATH) / path
    if not p.exists():
        old_content = ""
    else:
        old_content = p.read_text(encoding="utf8")
    diff = difflib.unified_diff(
        old_content.splitlines(keepends=True),
        new_content.splitlines(keepends=True),
        fromfile=f"a/{path}",
        tofile=f"b/{path}",
    )
    return "".join(diff) or "No changes."


def create_branch(branch_name: str):
    repo = Repo(LOCAL_REPO_PATH)
    if branch_name in repo.heads:
        repo.git.checkout(branch_name)
        return f"Checked out existing branch {branch_name}"
    else:
        new_branch = repo.create_head(branch_name)
        new_branch.checkout()
        return f"Created and checked out branch {branch_name}"


def commit_and_push(branch_name: str, commit_message: str):
    repo = Repo(LOCAL_REPO_PATH)
    repo.git.add(all=True)
    repo.index.commit(commit_message)
    repo.remotes.origin.push(branch_name)
    return f"Committed and pushed to {branch_name}"


def create_pull_request(branch_name: str, commit_message: str, instruction: str):
    gh_repo = gh.get_repo(f"{REPO_OWNER}/{REPO_NAME}")
    pr = gh_repo.create_pull(
        title=commit_message,
        body=f"Automated PR generated by instruction: {instruction}",
        head=branch_name,
        base=gh_repo.default_branch,
    )
    return f"PR created: {pr.html_url}"


# -------- Define tools for Groq --------

tools = [
    {
        "type": "function",
        "function": {
            "name": "clone_or_pull_repo",
            "description": "Clone the repo if not cloned, or pull latest changes",
            "parameters": {"type": "object", "properties": {}, "required": []},
        },
    },
    {
        "type": "function",
        "function": {
            "name": "list_files",
            "description": "List all files in the repo recursively",
            "parameters": {"type": "object", "properties": {}, "required": []},
        },
    },
    {
        "type": "function",
        "function": {
            "name": "find_files",
            "description": "Find files matching the filename anywhere in the repo",
            "parameters": {
                "type": "object",
                "properties": {
                    "filename": {"type": "string", "description": "Filename to search for"},
                },
                "required": ["filename"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "read_file",
            "description": "Read content of a file",
            "parameters": {
                "type": "object",
                "properties": {"path": {"type": "string", "description": "File path"}},
                "required": ["path"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "write_file",
            "description": "Write content to a file",
            "parameters": {
                "type": "object",
                "properties": {
                    "path": {"type": "string", "description": "File path"},
                    "content": {"type": "string", "description": "File content"},
                },
                "required": ["path", "content"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "get_diff",
            "description": "Get unified diff of existing file and new content",
            "parameters": {
                "type": "object",
                "properties": {
                    "path": {"type": "string", "description": "File path"},
                    "new_content": {"type": "string", "description": "New file content"},
                },
                "required": ["path", "new_content"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "create_branch",
            "description": "Create or checkout a branch",
            "parameters": {
                "type": "object",
                "properties": {"branch_name": {"type": "string", "description": "Branch name"}},
                "required": ["branch_name"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "commit_and_push",
            "description": "Commit all changes and push to branch",
            "parameters": {
                "type": "object",
                "properties": {
                    "branch_name": {"type": "string", "description": "Branch name"},
                    "commit_message": {"type": "string", "description": "Commit message"},
                },
                "required": ["branch_name", "commit_message"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "create_pull_request",
            "description": "Create a pull request on GitHub",
            "parameters": {
                "type": "object",
                "properties": {
                    "branch_name": {"type": "string", "description": "Branch name"},
                    "commit_message": {"type": "string", "description": "Commit message"},
                    "instruction": {"type": "string", "description": "Original user instruction"},
                },
                "required": ["branch_name", "commit_message", "instruction"],
            },
        },
    },
]


def main():
    user_instruction = input("Enter your instruction: ").strip()

    messages = [
        {
            "role": "system",
            "content": (
                "You are a coding assistant that uses these tools: clone_or_pull_repo, find_files, read_file, write_file, get_diff, create_branch, commit_and_push, create_pull_request.\n"
                "For every user instruction:\n"
                 "- First ensure the repo is cloned or up to date by calling clone_or_pull_repo.\n"
                "- Then find relevant files using find_files.\n"
                "- Then read files before editing.\n"
                "- Update the file with the according to the user request and write the updated code in the file using write_file tool according to the file extension write the code don't be write any code "
                "- Then write meaningful updates, showing diffs with get_diff.\n"
                "- Then create a branch, commit, push and create a PR.\n"
                "- Respond only with ONE function call at a time.\n"
                "- Wait for tool output before calling next function.\n"
                "- If no action is needed, respond with 'No action needed.'"
            ),
        },
        {"role": "user", "content": user_instruction},
    ]

    available_functions = {
        "clone_or_pull_repo": clone_or_pull_repo,
        "list_files": list_files,
        "find_files": find_files,
        "read_file": read_file,
        "write_file": write_file,
        "get_diff": get_diff,
        "create_branch": create_branch,
        "commit_and_push": commit_and_push,
        "create_pull_request": create_pull_request,
    }

    while True:
        response = client.chat.completions.create(
            model=model,
            messages=messages,
            tools=tools,
            tool_choice="auto",
            max_completion_tokens=4096,
            temperature=0.5,
        )

        response_message = response.choices[0].message
        tool_calls = response_message.tool_calls or []

        if not tool_calls:
            # No tool calls means task is complete or no action needed
            print("Assistant response:", response_message.content)
            break

        # Process exactly one tool call (as per system prompt)
        tool_call = tool_calls[0]
        fn_name = tool_call.function.name
        fn = available_functions.get(fn_name)
        args = json.loads(tool_call.function.arguments)

        print(f"Calling tool: {fn_name} with args: {args}")
        result = fn(**args)
        print(f"Result: {result}")

        # Add tool response back to conversation
        messages.append(response_message)
        messages.append(
            {
                "role": "tool",
                "content": result,
                "tool_call_id": tool_call.id,
            }
        )



if __name__ == "__main__":
    main()
